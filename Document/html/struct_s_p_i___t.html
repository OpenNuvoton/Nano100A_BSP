<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nano100AN Series BSP: SPI_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nano100AN Series BSP
   &#160;<span id="projectnumber">V3.02.002</span>
   </div>
   <div id="projectbrief">The Board Support Package for Nano100AN Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">SPI_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a069fd6acdea1842f24bba35267ff3ea5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a069fd6acdea1842f24bba35267ff3ea5">CTL</a></td></tr>
<tr class="separator:a069fd6acdea1842f24bba35267ff3ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afe2cb0c518f0dff54c05986b987f33"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a4afe2cb0c518f0dff54c05986b987f33">STATUS</a></td></tr>
<tr class="separator:a4afe2cb0c518f0dff54c05986b987f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea1e761f8c180884bc051c73db22e13"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a6ea1e761f8c180884bc051c73db22e13">CLKDIV</a></td></tr>
<tr class="separator:a6ea1e761f8c180884bc051c73db22e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5d65619694a5df1436bb9bc1f548d4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#acd5d65619694a5df1436bb9bc1f548d4">SSR</a></td></tr>
<tr class="separator:acd5d65619694a5df1436bb9bc1f548d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c47737acb74f2f2d9349a981d095b57"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a7c47737acb74f2f2d9349a981d095b57">RX0</a></td></tr>
<tr class="separator:a7c47737acb74f2f2d9349a981d095b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ec07fe66de05dbcb70bcce2a1f3272"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a62ec07fe66de05dbcb70bcce2a1f3272">RX1</a></td></tr>
<tr class="separator:a62ec07fe66de05dbcb70bcce2a1f3272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6b1c45e89186b0b38d4d5a03dfa063"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a2e6b1c45e89186b0b38d4d5a03dfa063">TX0</a></td></tr>
<tr class="separator:a2e6b1c45e89186b0b38d4d5a03dfa063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390d2928ba639001d0282683b53ceaf3"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a390d2928ba639001d0282683b53ceaf3">TX1</a></td></tr>
<tr class="separator:a390d2928ba639001d0282683b53ceaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762fced4160de55295b4d0854f24f66d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a762fced4160de55295b4d0854f24f66d">VARCLK</a></td></tr>
<tr class="separator:a762fced4160de55295b4d0854f24f66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e42f8471286af195d727aa51ee53afe"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a9e42f8471286af195d727aa51ee53afe">PDMA</a></td></tr>
<tr class="separator:a9e42f8471286af195d727aa51ee53afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d84fe6233cac9bf5cc3ea9f0128460"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a34d84fe6233cac9bf5cc3ea9f0128460">FFCLR</a></td></tr>
<tr class="separator:a34d84fe6233cac9bf5cc3ea9f0128460"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup SPI Serial Peripheral Interface Controller(SPI)
Memory Mapped Structure for SPI Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l07871">7871</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a6ea1e761f8c180884bc051c73db22e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea1e761f8c180884bc051c73db22e13">&#9670;&nbsp;</a></span>CLKDIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::CLKDIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>CLKDIV </h1>
<h2>Offset: 0x08 SPI Clock Divider Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]  </td><td class="markdownTableBodyCenter">DIVIDER1  </td><td class="markdownTableBodyLeft">Clock Divider 1 Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value in this field is the 1th frequency divider of the PCLK to generate the serial clock of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The desired frequency is obtained according to the following equation:   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1: The DIVIDER1 can be set as 0. If the DIVIDER1 is set as zero, the frequency of SPI_SCLK is the same as PCLK in Master mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: In Slave mode, the period of SPI clock driven by a master shall equal to or over 5 times the period of PCLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]  </td><td class="markdownTableBodyCenter">DIVIDER2  </td><td class="markdownTableBodyLeft">Clock Divider 2 Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value in this field is the 2nd frequency divider of the PCLK to generate the serial clock of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The desired frequency is obtained according to the following equation:   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l08039">8039</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a069fd6acdea1842f24bba35267ff3ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069fd6acdea1842f24bba35267ff3ea5">&#9670;&nbsp;</a></span>CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>CTL </h1>
<h2>Offset: 0x00 SPI Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">GO_BUSY  </td><td class="markdownTableBodyLeft">Go And Busy Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Writing this bit "0" to stop data transfer if SPI is transferring.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = In Master mode, writing "1" to this bit to start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the salve is ready to communicate with a master.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">During the data transfer, this bit keeps the value of '1'.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">As the transfer is finished, this bit will be cleared automatically.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1. All registers should be set before writing "1" to the GO_BUSY bit in the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">2. In FIFO mode, this bit will be controlled by hardware. Software should not modify this bit.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">RX_NEG  </td><td class="markdownTableBodyLeft">Receive At Negative Edge   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The received data is latched on the rising edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The received data is latched on the falling edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">TX_NEG  </td><td class="markdownTableBodyLeft">Transmit At Negative Edge   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transmitted data output is changed on the rising edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transmitted data output is changed on the falling edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:3]  </td><td class="markdownTableBodyCenter">TX_BIT_LEN  </td><td class="markdownTableBodyLeft">Transmit Bit Length   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field specifies how many bits are transmitted in one transmit/receive transaction.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Up to 32 bits can be transmitted.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00001 ~ 00111 aren't be used.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TX_BIT_LEN Description   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01000 8 bits are transmitted in one transaction   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01001 9 bits are transmitted in one transaction   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">---&mdash; -------&mdash;   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11111 31 bits are transmitted in one transaction   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00000 32 bits are transmitted in one transaction   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9:8]  </td><td class="markdownTableBodyCenter">TX_NUM  </td><td class="markdownTableBodyLeft">Number Of Transmit/Receive Transaction   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field specifies how many transmit/receive transaction should be executed in one transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Only one transmit/receive transaction will be executed in one transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Two successive transmit/receive transaction will be executed in one transfer (burst mode).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Reserved.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]  </td><td class="markdownTableBodyCenter">LSB  </td><td class="markdownTableBodyLeft">Send LSB First   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The MSB is transmitted/received first (which bit in SPI_TX register will be transmitted/received that is depends on the TX_BIT_LEN field in the CTRL register).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The LSB is sent first on the data line (TDATA[0]), and the first bit received from the data line will be put in the LSB position in the SPI_RX register (RDATA[0]).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]  </td><td class="markdownTableBodyCenter">CLKP  </td><td class="markdownTableBodyLeft">Clock Polarity   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The default level of SCLK is low in idle state.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The default level of SCLK is high in idle state.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:12]  </td><td class="markdownTableBodyCenter">SP_CYCLE  </td><td class="markdownTableBodyLeft">Suspend Interval (Master Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = "0".   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CLKP = "1", the interval is from the rising clock edge to the falling clock edge.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is 0000.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TX_NUM = 00, setting this field has no effect on transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The desired suspend interval is obtained according to the following equation:(SP_CYCLE[3:0] + 2)*period of SPICLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For byte suspend interval and burst mode suspend interval, suspend interval is SP__CYCLE + 2   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For FIFO mode suspend interval:   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE can't be set as 1.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If SP_CYCLE equals from 2 to 15, suspend interval period is   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(SP_CYCLE[3:0] + 3) * system clock period + 1 SPICLK clock cycle   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If SP_CYCLE = 0, suspend interval period is.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">35 * period of system clock + 1 SPICLK clock cycle   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In case of DIVIDER = 0, if SP_CYCLE = 2~15, suspend interval period is.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(SP_CYCLE[3:0] + 3.5) * system clock period   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Ex:   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0x2 ... 5.5 system clock periods.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">......   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0xE ... 17.5 system clock periods.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0xF ... 18.5 system clock periods.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">if SP_CYCLE = 0, suspend interval period is.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">35.5 * system clock period   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]  </td><td class="markdownTableBodyCenter">INTEN  </td><td class="markdownTableBodyLeft">Interrupt Enable   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI Interrupt Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI Interrupt Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]  </td><td class="markdownTableBodyCenter">SLAVE  </td><td class="markdownTableBodyLeft">Slave Mode Indication   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI controller is set as Master mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI controller is set as Slave mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[20:19]  </td><td class="markdownTableBodyCenter">REORDER  </td><td class="markdownTableBodyLeft">Reorder Mode Selection   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Disable both byte reorder and suspend functions.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Enable byte reorder function and insert a byte suspend interval among each byte.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The setting of TX_BIT_LEN must be configured as 00b ( 32 bits/ word).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Enable byte reorder function, but disable byte suspend function.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Disable byte reorder function, but insert a suspend interval among each byte.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The setting of TX_BIT_LEN must be configured as 00b ( 32 bits/ word).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The suspend interval is defined in SP_CYCLE.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1: Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: In Slave mode with level-trigger configuration, if the byte suspend function is enabled, the slave select pin must be kept at active state during the successive four bytes transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21]  </td><td class="markdownTableBodyCenter">FIFOM  </td><td class="markdownTableBodyLeft">Dual FIFO Mode Enable   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">There is another shadow FIFO in each FIFO register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can use it to improve the performance.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In normal mode, the transmitted/received data can only be updated/read back after the current transfer done.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO mode, the next transmitted and previous received data can be updated/read back during the current transfer period.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Normal mode. The dual transmitting and receiving FIFO is not used.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Dual FIFO mode. User can use the dual transmitting and receiving FIFO to improve its performance.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1:The FIFOM is active in one word transaction only. That means the TX_NUM shall be set as 00.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: Before enabling FIFO mode, the other related settings should be set in advance.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 3: In Slave mode with level-trigger configuration, the slave select pin must be kept at active state during the successive data transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 4: In FIFO mode, both the REORDER field and the TX_NUM field must be configured as 0.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In other words, the byte-reorder function, byte suspend function and burst mode must be disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[22]  </td><td class="markdownTableBodyCenter">TWOB  </td><td class="markdownTableBodyLeft">Two Bit Transfer Mode Active   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Two-bit transfer mode Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Two-bit transfer mode Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note that when enabling TWOB, the serial transmitted 2-bits data output are from SPI_TX1/0, and the received 2-bits data input are put into SPI_RX1/0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note that when enabling TWOB, the setting of TX_NUM must be programmed as 00.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23]  </td><td class="markdownTableBodyCenter">VARCLK_EN  </td><td class="markdownTableBodyLeft">Variable Clock Enable   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The serial clock output frequency is fixed and only decided by the value of DIVIDER1 (SPI_CLKDIV[15:0]).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The serial clock output frequency is variable.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The output frequency is decided by the value of VARCLK (SPI_VARCLK), DIVIDER1(SPI_CLKDIV[15:0]), and DIVIDER2(SPI_CLKDIV[31:16]).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]  </td><td class="markdownTableBodyCenter">WKEUP_EN  </td><td class="markdownTableBodyLeft">Wake-Up Enable   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Wake-up function Disabled when the system enters the power-down mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up function Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the system enters the power-down mode, the system can be wake-up from the SPI controller when this bit is enabled and if there is any toggle in the SPICLK port.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the system wake-up, this bit must be clear by user to disable the wake-up requirement.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l07984">7984</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a34d84fe6233cac9bf5cc3ea9f0128460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d84fe6233cac9bf5cc3ea9f0128460">&#9670;&nbsp;</a></span>FFCLR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::FFCLR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>FFCLR </h1>
<h2>Offset: 0x3C SPI FIFO Counter Clear Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">RX_CLR  </td><td class="markdownTableBodyLeft">Receiving FIFO Counter Clear   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is used to clear the receiver counter in FIFO Mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be written "1" to clear the receiver counter and this bit will be clear to "0" automatically after clearing receiving counter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the clear operation, the flag of RX_EMPTY in SPI_STATUS[0] will be set to "1".   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">TX_CLR  </td><td class="markdownTableBodyLeft">Transmitting FIFO Counter Clear   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is used to clear the transmit counter in FIFO Mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be written "1" to clear the transmitting counter and this bit will be clear to "0" automatically after clearing transmitting counter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the clear operation, the flag of TX_EMPTY in SPI_STATUS[2] will be set to "1".   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l08223">8223</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a9e42f8471286af195d727aa51ee53afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e42f8471286af195d727aa51ee53afe">&#9670;&nbsp;</a></span>PDMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::PDMA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>PDMA </h1>
<h2>Offset: 0x38 SPI PDMA Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">TX_DMA_EN  </td><td class="markdownTableBodyLeft">Transmit PDMA Enable (PDMA Writes Data To SPI)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to "1" will enable the transmitting PDMA process.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI transmit PDMA request will issue automatically when this bit is active and the GO_BUSY set "1".   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI transmit PDMA function Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI transmit PDMA function Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1: The bit shall be programmed before the GO_BUSY bit if the user wants to enable the DMA function.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: In DMA mode, the burst mode and FIFO mode are not support.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 3: It is auto cleared to 0 after the PDMA function done.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">RX_DMA_EN  </td><td class="markdownTableBodyLeft">Receiving PDMA Enable(PDMA Reads SPI Data To Memory)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to "1" will enable the receive PDMA process.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI module will issue request the PDMA function in receive channel when this bit active and the transaction has done.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the transmit PDMA process is enabled, the priority of receive PDMA in DMA block shall be higher than the transmit PDMA.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI receive PDMA function Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI receive PDMA function Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is auto cleared to "0" after the PDMA function done.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">PDMA_RST  </td><td class="markdownTableBodyLeft">PDMA Reset   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to reset the SPI PDMA function into default state.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = After reset PDMA function or in normal operation.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset PDMA function.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: it is auto cleared to "0" after the reset function done.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l08205">8205</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a7c47737acb74f2f2d9349a981d095b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c47737acb74f2f2d9349a981d095b57">&#9670;&nbsp;</a></span>RX0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SPI_T::RX0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>RX0 </h1>
<h2>Offset: 0x10 SPI Receive Data FIFO Register 0 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">RDATA  </td><td class="markdownTableBodyLeft">Receive Data FIFO Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The received data FIFO registers hold the value of received data of the last executed transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Valid bits depend on the transaction bit length field in the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example :   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX_BIT_LEN is set to 01000 and TX_NUM is set to 00, RDATA[7:0] holds the received data.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: These registers are read only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l08102">8102</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a62ec07fe66de05dbcb70bcce2a1f3272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ec07fe66de05dbcb70bcce2a1f3272">&#9670;&nbsp;</a></span>RX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SPI_T::RX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>RX1 </h1>
<h2>Offset: 0x14 SPI Receive Data FIFO Register 1 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">RDATA  </td><td class="markdownTableBodyLeft">Receive Data FIFO Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The received data FIFO registers hold the value of received data of the last executed transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Valid bits depend on the transaction bit length field in the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example :   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX_BIT_LEN is set to 01000 and TX_NUM is set to 00, RDATA[7:0] holds the received data.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: These registers are read only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l08118">8118</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="acd5d65619694a5df1436bb9bc1f548d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5d65619694a5df1436bb9bc1f548d4">&#9670;&nbsp;</a></span>SSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::SSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>SSR </h1>
<h2>Offset: 0x0C SPI Slave Select Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]  </td><td class="markdownTableBodyCenter">SSR  </td><td class="markdownTableBodyLeft">Slave Select Active Register (Master Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If AUTOSS bit is cleared, writing "1" to SSR[0] bit sets the SPISS[0] line to an active state and writing "0" sets the line back to inactive state.(the same as SSR[1] for SPISS[1])   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If AUTOSS bit is set, writing "1" to any bit location of this field will select appropriate SPISS[1:0] line to be automatically driven to active state for the duration of the transaction, and will be driven to inactive state for the rest of the time.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(The active level of SPISS[1:0] is specified in SS_LVL).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1: This interface can only drive one device/slave at a given time.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Therefore, the slaves select of the selected device must be set to its active level before starting any read or write transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: SPISS[0] is also defined as device/slave select input in Slave mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And that the slave select input must be driven by edge active trigger which level depend on the SS_LVL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">SS_LVL  </td><td class="markdownTableBodyLeft">Slave Select Active Level   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It defines the active level of device/slave select signal (SPISS[1:0]).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The SPI_SS slave select signal is active Low.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The SPI_SS slave select signal is active High.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]  </td><td class="markdownTableBodyCenter">AUTOSS  </td><td class="markdownTableBodyLeft">Automatic Slave Selection (Master Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = If this bit is set as "1", SPISS[1:0] signals are generated automatically.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It means that device/slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started by setting the GO_BUSY bit, and is de-asserted after each transaction is done.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]  </td><td class="markdownTableBodyCenter">SS_LTRIG  </td><td class="markdownTableBodyLeft">Slave Select Level Trigger   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The input slave select signal is edge-trigger.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The slave select signal will be level-trigger.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It depends on SS_LVL to decide the signal is active low or active high.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]  </td><td class="markdownTableBodyCenter">NOSLVSEL  </td><td class="markdownTableBodyLeft">No Slave Selected In Slave Mode   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is used to ignore the slave select signal in Slave mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The SPI controller can work on 3 wire interface including SPICLK, SPI_MISO, and SPI_MOSI when it is set as a slave device.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The controller is 4-wire bi-direction interface.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The controller is 3-wire bi-direction interface in Slave mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set as 1, the controller start to transmit/receive data after the GO_BUSY bit active and the serial clock input.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In no slave select signal mode, the SS_LTRIG, SPI_SSR[4], shall be set as "1".   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]  </td><td class="markdownTableBodyCenter">SLV_ABORT  </td><td class="markdownTableBodyLeft">Abort In Slave Mode With No Slave Selected   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In normal operation, there is interrupt event when the received data meet the required bits which define in TX_BIT_LEN and TX_NUM.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the received bits are less than the requirement and there is no more serial clock input over the time period which is defined by user in slave mode with no slave select, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is auto clear to "0" by hardware when the abort event is active.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]  </td><td class="markdownTableBodyCenter">SSTA_INTEN  </td><td class="markdownTableBodyLeft">Slave Start Interrupt Enable   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to enable interrupt when the transfer has started in Slave mode with no slave select.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If there is no transfer done interrupt over the time period which is defined by user after the transfer start, the user can set the SLV_ABORT bit to force the transfer done.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transfer start interrupt Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transaction start interrupt Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is cleared when the current transfer done or the SLV_START_INTSTS bit cleared (write one clear).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l08086">8086</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a4afe2cb0c518f0dff54c05986b987f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afe2cb0c518f0dff54c05986b987f33">&#9670;&nbsp;</a></span>STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>STATUS </h1>
<h2>Offset: 0x04 SPI Status Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">RX_EMPTY  </td><td class="markdownTableBodyLeft">Received Dual FIFO_EMPTY Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Received data FIFO is not empty in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Received data FIFO is empty in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">RX_FULL  </td><td class="markdownTableBodyLeft">Received Dual FIFO_FULL Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Received data FIFO is not full in dual FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Received data FIFO is full in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">TX_EMPTY  </td><td class="markdownTableBodyLeft">Transmitted Dual FIFO_EMPTY Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmitted data FIFO is not empty in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 =Transmitted data FIFO is empty in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]  </td><td class="markdownTableBodyCenter">TX_FULL  </td><td class="markdownTableBodyLeft">Transmitted Dual FIFO_FULL Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmitted data FIFO is not full in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transmitted data FIFO is full in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]  </td><td class="markdownTableBodyCenter">LTRIG_FLAG  </td><td class="markdownTableBodyLeft">Level Trigger Flag   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the SS_LTRIG bit is set as level trigger in Slave mode, this bit can be read to indicate the received bit number is met the requirement or not.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One of the received number and the received bit length doesn't meet the requirement in one transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The received number and received bits met the requirement which defines in TX_NUM and TX_BIT_LEN among one transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is READ only   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]  </td><td class="markdownTableBodyCenter">SLV_START_INTSTS  </td><td class="markdownTableBodyLeft">Slave Start Interrupt Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to dedicate that the transfer has started in Slave mode with no slave select.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Slave started transfer no active.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transfer has started in Slave mode with no slave select.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is auto clear by transfer done or writing one clear.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]  </td><td class="markdownTableBodyCenter">INTSTS  </td><td class="markdownTableBodyLeft">Interrupt Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transfer is not finished yet.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transfer is done. The interrupt is requested when the INTEN bit is enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to this bit.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l08020">8020</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a2e6b1c45e89186b0b38d4d5a03dfa063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6b1c45e89186b0b38d4d5a03dfa063">&#9670;&nbsp;</a></span>TX0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SPI_T::TX0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>TX0 </h1>
<h2>Offset: 0x20 SPI Transmit Data FIFO Register 0 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">TDATA  </td><td class="markdownTableBodyLeft">Transmit Data FIFO Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The transmit data FIFO registers hold the data to be transmitted in the next transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Valid bits depend on the transaction bit length field in the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example :   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1). If TX_BIT_LEN is set to 01000 and the TX_NUM is set to 00, TDATA[7:0] will be transmitted in next transaction.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(2). If TX_BIT_LEN is set to 00000 and TX_NUM is set to 01, the core will perform two 32-bit transmit/receive successive using the same setting (the order is TDATA0[31:0], TDATA1[31:0]).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l08139">8139</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a390d2928ba639001d0282683b53ceaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390d2928ba639001d0282683b53ceaf3">&#9670;&nbsp;</a></span>TX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SPI_T::TX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>TX1 </h1>
<h2>Offset: 0x24 SPI Transmit Data FIFO Register 1 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">TDATA  </td><td class="markdownTableBodyLeft">Transmit Data FIFO Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The transmit data FIFO registers hold the data to be transmitted in the next transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Valid bits depend on the transaction bit length field in the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example :   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1). If TX_BIT_LEN is set to 01000 and the TX_NUM is set to 00, TDATA[7:0] will be transmitted in next transaction.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(2). If TX_BIT_LEN is set to 00000 and TX_NUM is set to 01, the core will perform two 32-bit transmit/receive successive using the same setting (the order is TDATA0[31:0], TDATA1[31:0]).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l08155">8155</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a762fced4160de55295b4d0854f24f66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762fced4160de55295b4d0854f24f66d">&#9670;&nbsp;</a></span>VARCLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::VARCLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>VARCLK </h1>
<h2>Offset: 0x34 SPI Variable Clock Pattern Flag Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">VARCLK  </td><td class="markdownTableBodyLeft">Variable Clock Pattern Flag   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value in this field is the frequency patterns of the SPICLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit pattern of VARCLK is '0', the output frequency of SPICLK is according the value of DIVIDER1.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit patterns of VARCLK are '1', the output frequency of SPICLK is according the value of DIVIDER2.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is used for CLKP = 0 only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l08175">8175</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/Users/yachen/workzone/bsp/nano100absp/Library/Device/Nuvoton/Nano100Series/Include/<a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 18:49:28 for Nano100AN Series BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
